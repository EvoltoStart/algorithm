Index: xxx/xx.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package xxx\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n\tfmt.Println(\"xxx\")\r\n\tfmt.Println(\"<>\")\r\n\r\n\r\n\tfmt.Println(\"<>\")\r\n\r\n}\r\n\r\nfunc subsets(nums []int) [][]int {\r\n\tans := make([][]int, 1<<len(nums))\r\n\tfor i := range ans { // 枚举全集 U 的所有子集 i，i就是一个子集\r\n\t\tfor j, x := range nums {\r\n\t\t\tif i>>j&1 == 1 { // j 在集合 i 中，j是一个元素\r\n\t\t\t\tans[i] = append(ans[i], x)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn ans\r\n}\r\n\r\nfunc permute(nums []int) (ans [][]int) {\r\n\tn := len(nums)\r\n\tpath := make([]int, n)\r\n\tonPath := make([]bool, n)\r\n\tvar dfs func(int)\r\n\tdfs = func(i int) {\r\n\t\tif i == n {\r\n\t\t\tans = append(ans, append([]int(nil), path...))\r\n\t\t\treturn\r\n\t\t}\r\n\t\tfor j, on := range onPath {\r\n\t\t\tif !on {\r\n\t\t\t\tpath[i] = nums[j]\r\n\t\t\t\tonPath[j] = true //访问后\r\n\t\t\t\tdfs(i + 1)\r\n\t\t\t\tonPath[j] = false //恢复未访问的状态\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tdfs(0)\r\n\treturn\r\n}\r\n\r\nvar mapping = [...]string{\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}\r\n\r\nfunc letterCombinations(digits string) (ans []string) {\r\n\tn := len(digits)\r\n\tif n == 0 {\r\n\t\treturn\r\n\t}\r\n\r\n\tpath := make([]byte, n) // 注意 path 长度一开始就是 n，不是空列表\r\n\r\n\tvar dfs func(int)\r\n\tdfs = func(i int) {\r\n\t\tif i == n {\r\n\t\t\tans = append(ans, string(path))\r\n\t\t\treturn\r\n\t\t}\r\n\t\tfor _, c := range mapping[digits[i]-'0'] {\r\n\t\t\tpath[i] = byte(c) // 直接覆盖\r\n\t\t\tdfs(i + 1)\r\n\t\t}\r\n\t}\r\n\r\n\tdfs(0)\r\n\treturn\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/xxx/xx.go b/xxx/xx.go
--- a/xxx/xx.go	(revision 7e981c31413eaa7b6110e8d596c65376c39d5c7d)
+++ b/xxx/xx.go	(date 1756651071380)
@@ -1,12 +1,14 @@
 package xxx
 
-import "fmt"
+import (
+	"fmt"
+	"slices"
+)
 
 func main() {
 	fmt.Println("xxx")
 	fmt.Println("<>")
 
-
 	fmt.Println("<>")
 
 }
@@ -71,3 +73,68 @@
 	dfs(0)
 	return
 }
+func combinationSum(candidates []int, target int) (ans [][]int) {
+	n := len(candidates)
+	// 完全背包
+	f := make([][]bool, n+1) //n+1 target+1 考虑边界情况
+	f[0] = make([]bool, target+1)
+	f[0][0] = true
+	for i, x := range candidates {
+		f[i+1] = make([]bool, target+1)
+		for j, b := range f[i] {
+			f[i+1][j] = b || j >= x && f[i+1][j-x] //(b || j >= x && f[i+1][j-x]),‘=’优先级最低
+		}
+	}
+
+	path := []int{}
+	var dfs func(int, int)
+	dfs = func(i, left int) {
+		if left == 0 {
+			// 找到一个合法组合
+			ans = append(ans, slices.Clone(path))
+			return
+		}
+
+		// 无法用下标在 [0, i] 中的数字组合出 left
+		if left < 0 || !f[i+1][left] {
+			return
+		}
+
+		// 不选
+		dfs(i-1, left)
+
+		// 选
+		path = append(path, candidates[i]) // 把当前数加入路径
+		dfs(i, left-candidates[i])         // 继续用 i（因为可以重复选）
+		path = path[:len(path)-1]          // 回溯，撤销选择
+
+	}
+
+	// 倒着递归，这样参数符合 f 数组的定义
+	dfs(n-1, target)
+	return ans
+}
+
+func generateParenthesis(n int) (ans []string) {
+	path := make([]byte, n*2) // 所有括号长度都是一样的 2n
+
+	// 目前填了 left 个左括号，right 个右括号
+	var dfs func(int, int)
+	dfs = func(left, right int) {
+		if right == n { // 填完 2n 个括号
+			ans = append(ans, string(path)) // 加入答案
+			return
+		}
+		if left < n { // 可以填左括号
+			path[left+right] = '(' // 直接覆盖
+			dfs(left+1, right)
+		}
+		if right < left { // 可以填右括号
+			path[left+right] = ')' // 直接覆盖
+			dfs(left, right+1)
+		}
+	}
+
+	dfs(0, 0) // 一开始没有填括号
+	return
+}
