Index: xxx/xx.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package xxx\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"slices\"\r\n)\r\n\r\nfunc main() {\r\n\tfmt.Println(\"xxx\")\r\n\tfmt.Println(\"<>\")\r\n\r\n\tfmt.Println(\"<>\")\r\n\r\n}\r\n\r\nfunc subsets(nums []int) [][]int {\r\n\tans := make([][]int, 1<<len(nums))\r\n\tfor i := range ans { // 枚举全集 U 的所有子集 i，i就是一个子集\r\n\t\tfor j, x := range nums {\r\n\t\t\tif i>>j&1 == 1 { // j 在集合 i 中，j是一个元素\r\n\t\t\t\tans[i] = append(ans[i], x)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn ans\r\n}\r\n\r\nfunc permute(nums []int) (ans [][]int) {\r\n\tn := len(nums)\r\n\tpath := make([]int, n)\r\n\tonPath := make([]bool, n)\r\n\tvar dfs func(int)\r\n\tdfs = func(i int) {\r\n\t\tif i == n {\r\n\t\t\tans = append(ans, append([]int(nil), path...))\r\n\t\t\treturn\r\n\t\t}\r\n\t\tfor j, on := range onPath {\r\n\t\t\tif !on {\r\n\t\t\t\tpath[i] = nums[j]\r\n\t\t\t\tonPath[j] = true //访问后\r\n\t\t\t\tdfs(i + 1)\r\n\t\t\t\tonPath[j] = false //恢复未访问的状态\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tdfs(0)\r\n\treturn\r\n}\r\n\r\nvar mapping = [...]string{\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}\r\n\r\nfunc letterCombinations(digits string) (ans []string) {\r\n\tn := len(digits)\r\n\tif n == 0 {\r\n\t\treturn\r\n\t}\r\n\r\n\tpath := make([]byte, n) // 注意 path 长度一开始就是 n，不是空列表\r\n\r\n\tvar dfs func(int)\r\n\tdfs = func(i int) {\r\n\t\tif i == n {\r\n\t\t\tans = append(ans, string(path))\r\n\t\t\treturn\r\n\t\t}\r\n\t\tfor _, c := range mapping[digits[i]-'0'] {\r\n\t\t\tpath[i] = byte(c) // 直接覆盖\r\n\t\t\tdfs(i + 1)\r\n\t\t}\r\n\t}\r\n\r\n\tdfs(0)\r\n\treturn\r\n}\r\n\r\nfunc combinationSum(candidates []int, target int) (ans [][]int) {\r\n\tn := len(candidates)\r\n\t// 完全背包\r\n\tf := make([][]bool, n+1) //n+1 target+1 考虑边界情况\r\n\tf[0] = make([]bool, target+1)\r\n\tf[0][0] = true\r\n\tfor i, x := range candidates {\r\n\t\tf[i+1] = make([]bool, target+1)\r\n\t\tfor j, b := range f[i] {\r\n\t\t\tf[i+1][j] = b || j >= x && f[i+1][j-x] //(b || j >= x && f[i+1][j-x]),‘=’优先级最低\r\n\t\t}\r\n\t}\r\n\r\n\tpath := []int{}\r\n\tvar dfs func(int, int)\r\n\tdfs = func(i, left int) {\r\n\t\tif left == 0 {\r\n\t\t\t// 找到一个合法组合\r\n\t\t\tans = append(ans, slices.Clone(path))\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// 无法用下标在 [0, i] 中的数字组合出 left\r\n\t\tif left < 0 || !f[i+1][left] {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// 不选\r\n\t\tdfs(i-1, left)\r\n\r\n\t\t// 选\r\n\t\tpath = append(path, candidates[i]) // 把当前数加入路径\r\n\t\tdfs(i, left-candidates[i])         // 继续用 i（因为可以重复选）\r\n\t\tpath = path[:len(path)-1]          // 回溯，撤销选择\r\n\r\n\t}\r\n\r\n\t// 倒着递归，这样参数符合 f 数组的定义\r\n\tdfs(n-1, target)\r\n\treturn ans\r\n}\r\n\r\nfunc generateParenthesis(n int) (ans []string) {\r\n\tpath := make([]byte, n*2) // 所有括号长度都是一样的 2n\r\n\r\n\t// 目前填了 left 个左括号，right 个右括号\r\n\tvar dfs func(int, int)\r\n\tdfs = func(left, right int) {\r\n\t\tif right == n { // 填完 2n 个括号\r\n\t\t\tans = append(ans, string(path)) // 加入答案\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif left < n { // 可以填左括号\r\n\t\t\tpath[left+right] = '(' // 直接覆盖\r\n\t\t\tdfs(left+1, right)\r\n\t\t}\r\n\t\tif right < left { // 可以填右括号\r\n\t\t\tpath[left+right] = ')' // 直接覆盖\r\n\t\t\tdfs(left, right+1)\r\n\t\t}\r\n\t}\r\n\r\n\tdfs(0, 0) // 一开始没有填括号\r\n\treturn\r\n}\r\n\r\n//..\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/xxx/xx.go b/xxx/xx.go
--- a/xxx/xx.go	(revision a6067e1ee047ff1d9c813d73159be6e87b961d06)
+++ b/xxx/xx.go	(date 1756652864523)
@@ -140,4 +140,5 @@
 	return
 }
 
-//..
+//
+//
